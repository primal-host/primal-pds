package domain

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// traefikConfigFile is the filename written to the Traefik dynamic
// config directory. Traefik's file provider watches the directory and
// reloads when this file changes.
const traefikConfigFile = "primal-pds.yml"

// traefikTmpl renders the Traefik dynamic configuration for all active
// domains. Each domain gets its own router that matches the base domain
// and all subdomains (for handle resolution). All routers share a single
// load-balanced service pointing to the primal-pds container.
//
// The template uses Go raw strings concatenated with backtick literals
// to produce the Traefik Host() and HostRegexp() rule syntax.
var traefikTmpl = template.Must(template.New("traefik").Parse(
	"# Auto-generated by primal-pds. Do not edit manually.\n" +
		"http:\n" +
		"  routers:\n" +
		"{{- range .Domains }}\n" +
		"    primal-pds-{{ .SafeName }}:\n" +
		"      rule: \"Host(`{{ .Domain }}`) || HostRegexp(`^.+\\\\.{{ .DomainEscaped }}$`)\"\n" +
		"      entrypoints:\n" +
		"        - https\n" +
		"      tls:\n" +
		"        certResolver: letsencrypt-dns\n" +
		"        domains:\n" +
		"          - main: \"{{ .Domain }}\"\n" +
		"            sans:\n" +
		"              - \"*.{{ .Domain }}\"\n" +
		"      service: primal-pds\n" +
		"{{- end }}\n" +
		"  services:\n" +
		"    primal-pds:\n" +
		"      loadBalancer:\n" +
		"        servers:\n" +
		"          - url: \"http://primal-pds:3000\"\n"))

// tmplDomain holds rendering data for a single domain entry.
type tmplDomain struct {
	Domain        string // original domain name
	DomainEscaped string // dots escaped for regex
	SafeName      string // sanitized for use as a Traefik router key
}

// tmplData is the top-level context passed to the template.
type tmplData struct {
	Domains []tmplDomain
}

// WriteTraefikConfig queries all active domains and writes (or removes)
// the Traefik dynamic configuration file. It uses atomic write (temp file
// + rename) so Traefik never reads a partially-written file.
func (s *Store) WriteTraefikConfig(ctx context.Context, configDir string) error {
	if configDir == "" {
		return nil // Traefik integration disabled
	}

	domains, err := s.ListActive(ctx)
	if err != nil {
		return fmt.Errorf("traefik: list active domains: %w", err)
	}

	outPath := filepath.Join(configDir, traefikConfigFile)

	// No active domains â€” remove the config so Traefik stops routing.
	if len(domains) == 0 {
		if err := os.Remove(outPath); err != nil && !os.IsNotExist(err) {
			return fmt.Errorf("traefik: remove config: %w", err)
		}
		return nil
	}

	data := tmplData{}
	for _, d := range domains {
		data.Domains = append(data.Domains, tmplDomain{
			Domain:        d.Domain,
			DomainEscaped: strings.ReplaceAll(d.Domain, ".", "\\."),
			SafeName:      sanitizeName(d.Domain),
		})
	}

	// Write to a temp file in the same directory, then rename into place.
	// Rename is atomic on Linux (where Docker runs), preventing Traefik
	// from reading a half-written file.
	tmpPath := outPath + ".tmp"
	f, err := os.Create(tmpPath)
	if err != nil {
		return fmt.Errorf("traefik: create temp file: %w", err)
	}

	if err := traefikTmpl.Execute(f, data); err != nil {
		f.Close()
		os.Remove(tmpPath)
		return fmt.Errorf("traefik: execute template: %w", err)
	}

	if err := f.Close(); err != nil {
		os.Remove(tmpPath)
		return fmt.Errorf("traefik: close temp file: %w", err)
	}

	if err := os.Rename(tmpPath, outPath); err != nil {
		os.Remove(tmpPath)
		return fmt.Errorf("traefik: rename config: %w", err)
	}

	return nil
}

// sanitizeName converts a domain into a safe Traefik router identifier
// by replacing dots and underscores with hyphens.
func sanitizeName(domain string) string {
	r := strings.NewReplacer(".", "-", "_", "-")
	return r.Replace(domain)
}
